//动态规划（Dynamic Programming）概述

//动态规划是运筹学的一个分支，是求解决策过程最优化的数学方法。最优化原理，它利用各阶段之间的关系，逐个求解，最终求得全局最优解。
//在设计动态规划算法时，需要确认原问题与子问题、动态规划状态、边界状态结值、状态转移方程等关键要素。

//在算法面试中，动态规划是最常考察的题型之一，大多数面试官都以否可较好的解决动态规划相关问题来区分候选是否"聪明"。

//例1：爬楼梯
//解法1：暴力搜索，回溯法
//这个方法，等n = 45 时，该方法是不可以提交leetcode的，原因就是超时了。
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1 || n == 2){
            return n;
        }
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
};

//思考：到达楼梯的第i阶有多少种爬法，与第几阶的爬法直接相关，如何递推的求出第i阶爬法数量？
//分析：由于每次最多爬2阶，楼梯的第i阶，只可能从楼梯的第i-1阶和第i-2阶到达，所以到达第i阶有多少种爬法，只与第i-1阶，第i-2阶的爬法数量直接相关
//第i阶的爬法数量 = 第i-1阶的爬法数量 + 第i-2阶的爬法数量
//算法思路：
//1.设置递推数组dp[0……n]，dp[i]代表的是到第i阶的爬法数量，就是有多少种走法，初始化数组为0
//2.设置到达第1阶台阶，有1种走法，到达第2阶台阶，有2种走法
//3.利用i循环递推从第3阶到第n阶的结果：到达第i阶的走法数量 = 到达第i-1阶的走法数量 + 到达第i-2阶的走法数量
//解法2：动态规划
class Solution {
public:
    int climbStairs(int n) {
            std::vector<int> dp(n+3, 0);
            dp[1] = 1;
            dp[2] = 2;

            for(int i = 3; i <= n; i++){
                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];
    }
};

//动态规划原理
//1.确认原问题和子问题
//原问题是求第n阶台阶所有走法的数量，子问题是求1阶台阶，2阶台阶、……、n-1阶台阶的走法数量
//2.确认状态：
//本题爬楼梯动态规划的状态单一，第i个状态就是为i阶台阶的所有走法数量
//3.确认边界状态的值：
//边界状态为1阶台阶与2阶台阶的走法，1阶台阶有1种走法，2阶台阶有两种走法，即dp[1] = 1; dp[2] = 2
//4.确认状态转移方程：
//将求第i个状态的值转移为求第i-1个状态值与第i-2个状态的值，动态规划转移方程，dp[i] = dp[i - 1] + dp[i - 2]
//------------------------------------------------------------------------------------------------------------------------------

//例2：打家劫舍

















