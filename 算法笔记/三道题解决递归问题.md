# 递归解题三部曲
何为递归？程序反复调用自身即是递归。  
既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，**因此我们只需要关注一级递归的解决过程即可**。  
我们需要关心的主要是以下三点：  
1.整个递归的终止条件。  
2.一级递归需要做什么？  
3.应该返回给上一级的返回值是什么？  
因此，也就有了我们解递归题的三部曲：  
1.找整个递归的终止条件：递归应该在什么时候结束？  
2.找返回值：应该给上一级返回什么信息？  
3.本级递归应该做什么：在这一级递归中，应该完成什么任务？  

## 例1：求二叉树的最大深度  
先看一道简单的Leetcode题目： Leetcode 104. 二叉树的最大深度  
1.**找到终止条件**：什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了  
2.**找到返回值**。应该返回什么呢？题目要求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回
值应该是当前树的最大深度，这一步可以结合第三步来看  
3.**本级递归应该做什么**，首先，还是强调要走出之前的思维误区，递归后我们眼里的树应该是只有一个root、root.left、root.rifht这样的节点
其中根据第二步，root.left、root.rifht分别记录的就是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树
中选择较大一个，再加上1就是root为根的子树的最大深度了，然后再返回这个深度即可。  
  
具体的cpp代码如下：
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};//执行用时：0ms 内存消耗：18.4MB
```

